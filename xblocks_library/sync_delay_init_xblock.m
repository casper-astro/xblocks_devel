%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%   Center for Astronomy Signal Processing and Electronics Research           %
%   http://casper.berkeley.edu                                                %      
%   Copyright (C) 2011 Hong Chen                                              %
%                                                                             %
%   This program is free software; you can redistribute it and/or modify      %
%   it under the terms of the GNU General Public License as published by      %
%   the Free Software Foundation; either version 2 of the License, or         %
%   (at your option) any later version.                                       %
%                                                                             %
%   This program is distributed in the hope that it will be useful,           %
%   but WITHOUT ANY WARRANTY; without even the implied warranty of            %
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             %
%   GNU General Public License for more details.                              %
%                                                                             %
%   You should have received a copy of the GNU General Public License along   %
%   with this program; if not, write to the Free Software Foundation, Inc.,   %
%   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.               %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function sync_delay_init_xblock(blk, latency)

% Semi-empirical threshold after which to use a counter
% as a pulse generator rather than SRLs for delay. 
% Counters take log2(bit_width) slices.  This is roughly the delay
% for which it becomes more efficient to use the counter, although it
% is hard to predict exactly the equilibrium point due to synthesis 
% ambiguity. 
% A delay of 256 can be implemented in 16 SRLs, or an 8-slice counter
% (plus some other stuff)
use_counter_threshold = 256;
 

% Mask Initialization code
bit_width = max(2, ceil(log2(latency+1)));

%% inports
In = xInport('In');

%% outports
Out = xOutport('Out');

%% diagram
if latency <= use_counter_threshold
	xBlock( struct('source', 'Delay', 'name', 'sync_del'), ...
		struct('latency', latency), {In}, {Out} );

else 
	% block: delay_7/sync_delay/Constant
	Constant_out1 = xSignal;
	Constant = xBlock(struct('source', 'Constant', 'name', 'Constant'), ...
							 struct('arith_type', 'Unsigned', ...
									'n_bits', bit_width, ...
									'bin_pt', 0, ...
									'explicit_period', 'on'), ...
							 {}, ...
							 {Constant_out1});
	
	% block: delay_7/sync_delay/Constant1
	Constant1_out1 = xSignal;
	Constant1 = xBlock(struct('source', 'Constant', 'name', 'Constant1'), ...
							  struct('arith_type', 'Unsigned', ...
									 'const', 0, ...
									 'n_bits', bit_width, ...
									 'bin_pt', 0, ...
									 'explicit_period', 'on'), ...
							  {}, ...
							  {Constant1_out1});
	
	% block: delay_7/sync_delay/Constant2
	Constant2_out1 = xSignal;
	Constant2 = xBlock(struct('source', 'Constant', 'name', 'Constant2'), ...
							  struct('arith_type', 'Unsigned', ...
									 'const', latency, ...
									 'n_bits', bit_width, ...
									 'bin_pt', 0, ...
									 'explicit_period', 'on'), ...
							  {}, ...
							  {Constant2_out1});
	
	% block: delay_7/sync_delay/Counter
	Logical_out1 = xSignal;
	Counter_out1 = xSignal;
	Counter = xBlock(struct('source', 'Counter', 'name', 'Counter'), ...
							struct('operation', 'Down', ...
								   'n_bits', bit_width, ...
								   'load_pin', 'on', ...
								   'en', 'on', ...
								   'use_rpm', 'on'), ...
							{In, Constant2_out1, Logical_out1}, ...
							{Counter_out1});
	
	% block: delay_7/sync_delay/Logical
	Relational1_out1 = xSignal;
	Logical = xBlock(struct('source', 'Logical', 'name', 'Logical'), ...
							struct('logical_function', 'OR', ...
								   'n_bits', 8, ...
								   'bin_pt', 2), ...
							{In, Relational1_out1}, ...
							{Logical_out1});
	
	% block: delay_7/sync_delay/Relational
	Relational = xBlock(struct('source', 'Relational', 'name', 'Relational'), ...
							   struct('latency', 0), ...
							   {Constant_out1, Counter_out1}, ...
							   {Out});
	
	% block: delay_7/sync_delay/Relational1
	Relational1 = xBlock(struct('source', 'Relational', 'name', 'Relational1'), ...
								struct('mode', 'a!=b', ...
									   'latency', 0), ...
								{Counter_out1, Constant1_out1}, ...
								{Relational1_out1});

end

