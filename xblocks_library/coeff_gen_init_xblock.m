%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%   Center for Astronomy Signal Processing and Electronics Research           %
%   http://casper.berkeley.edu                                                %      
%   Copyright (C) 2011 Suraj Gowda, Hong Chen                                 %
%                                                                             %
%   This program is free software; you can redistribute it and/or modify      %
%   it under the terms of the GNU General Public License as published by      %
%   the Free Software Foundation; either version 2 of the License, or         %
%   (at your option) any later version.                                       %
%                                                                             %
%   This program is distributed in the hope that it will be useful,           %
%   but WITHOUT ANY WARRANTY; without even the implied warranty of            %
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             %
%   GNU General Public License for more details.                              %
%                                                                             %
%   You should have received a copy of the GNU General Public License along   %
%   with this program; if not, write to the Free Software Foundation, Inc.,   %
%   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.               %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function coeff_gen_init_xblock(blk, Coeffs, coeff_bit_width, StepPeriod, bram_latency, coeffs_bram)

single_rom_size = 1024; %% May be architecture specific.  1024 is the V5 limit

%% initialization scripts

if( ~isempty(find(real(Coeffs) > 1, 1)) || ~isempty(find(imag(Coeffs) > 1, 1)) ),
    clog(['coeff_gen_init: [',num2str(Coeffs,4),'] not all in range [-1->1]'],'error');
    error('coeff_gen_init: Coefficients specified are out of range');
end
use_bram = strcmp(coeffs_bram, 'on');

%% inports
rst = xInport('rst');

%% outports
w = xOutport('w');

%% diagram
                 
if length(Coeffs) == 1,
        
    %terminator
    Terminator = xBlock(struct('source','Terminator', 'name', 'Terminator'), ...
                               [], ...
                               {rst}, ...
                               {});
    %constant blocks
    real_coeff = round(real(Coeffs(1)) * 2^(coeff_bit_width-2)) / 2^(coeff_bit_width-2);
    imag_coeff = round(imag(Coeffs(1)) * 2^(coeff_bit_width-2)) / 2^(coeff_bit_width-2);
    
    % block: untitled/coeff_gen/Constant
    Constant_out1 = xSignal;
    Constant = xBlock(struct('source', 'Constant', 'name', 'Constant'), ...
                             struct('n_bits', coeff_bit_width, ...
                                    'bin_pt', coeff_bit_width-2, ...
                                    'const', real_coeff, ...
                                    'explicit_period', 'on', ...
                                    'period', 1), ...
                             {}, ...
                             {Constant_out1});

    % block: untitled/coeff_gen/Constant1
    Constant1_out1 = xSignal;
    Constant1 = xBlock(struct('source', 'Constant', 'name', 'Constant1'), ...
                              struct('const', imag_coeff, ...
                                     'n_bits', coeff_bit_width, ...
                                     'bin_pt', coeff_bit_width-2, ...
                                     'explicit_period', 'on', ...
                                     'period', 1), ...
                              {}, ...
                              {Constant1_out1});
 
                          % block: twiddles_collections/coeff_gen/ri_to_c
    ri_to_c = xBlock(struct('source', str2func('ri_to_c_init_xblock'), 'name', 'ri_to_c'), ...
                          [], ...
                           {Constant_out1, Constant1_out1}, ...
                           {w});
else   
    if use_bram,
        mem = 'Block RAM';
    else
        mem = 'Distributed memory';
    end
    vlen = length(Coeffs);
    real_coeffs = round( real(Coeffs) * 2^(coeff_bit_width-2) ) / 2^(coeff_bit_width-2);
    imag_coeffs = round( imag(Coeffs) * 2^(coeff_bit_width-2)  ) / 2^(coeff_bit_width-2);
    
    cycle_count = xSignal;
    coeff_addr = xSignal;
    real_coeff_rom_out = xSignal;
    imag_coeff_rom_out = xSignal;    
    
    Counter = xBlock(struct('source', 'Counter', 'name', 'Counter'), ...
                            struct('n_bits', log2(vlen)+StepPeriod, ...
                                   'cnt_type', 'Free Running', ...
                                   'start_count', 0, ...
                                   'cnt_by_val', 1, ...
                                   'arith_type', 'Unsigned', ...
                                   'bin_pt', 0, ...
                                   'rst', 'on'), ...
                            {rst}, ...
                            {cycle_count});

    Slice = xBlock(struct('source', 'Slice', 'name', 'Slice'), ...
                          struct('nbits', log2(vlen), ...
                                 'mode', 'Upper Bit Location + Width', ...
                                 'bit1', 0, ...
                                 'base1', 'MSB of Input'), ...
                          {cycle_count}, ...
                          {coeff_addr});                        
	
    if 2*vlen <= single_rom_size && use_bram 
        coeff_addr_padded = xSignal;
        addr_a = xSignal;
        addr_b = xSignal;
        addr_b_top = xSignal;
        % pack the two coefficients into one vector
        rom_init_vec = zeros(1,single_rom_size);
        rom_init_vec(1:vlen) = real_coeffs;
        rom_init_vec(1+single_rom_size/2:vlen+single_rom_size/2) = imag_coeffs;
        
        % dummy data and we inputs for BRAM
        bram_din = xSignal;
        bram_we = xSignal;
        xBlock(struct('source', 'Constant', 'name', 'bram_din_const'), ...
            struct('const', 0, 'n_bits', coeff_bit_width, 'bin_pt', coeff_bit_width-2, ...
                'arith_type', 'Signed (2''s comp)'), ...
            {}, {bram_din});

        xBlock(struct('source', 'Constant', 'name', 'bram_we_const'), ...
            struct('const', 0, 'arith_type', 'Boolean'), ...
            {}, {bram_we});
        
        % pad the coeff_addr to 10 bits
        xBlock(struct('source', 'Convert', 'name', 'cnt_sign_exta'), ...
            struct('arith_type', 'Unsigned', 'n_bits', log2(single_rom_size), ...
                'bin_pt', 0), {coeff_addr}, {addr_a});
        
        xBlock(struct('source', 'Convert', 'name', 'cnt_sign_extb'), ...
            struct('arith_type', 'Unsigned', 'n_bits', log2(single_rom_size/2), ...
                'bin_pt', 0), {coeff_addr}, {coeff_addr_padded});
        
        xBlock(struct('source', 'Constant', 'name', 'counter_b_pad'), ...
            struct('const', 1, 'arith_type', 'Unsigned', 'n_bits', 1, 'bin_pt', 0), ...
            {}, {addr_b_top});
        
        xBlock(struct('source', 'Concat', 'name', 'counter_b_concat'), ...
            [], {addr_b_top, coeff_addr_padded}, {addr_b});
        
        
        % instantiate dual port ROM
        xBlock( struct('source', 'Dual Port RAM', 'name', 'coeff_mem'), ...
            struct('latency', bram_latency, 'distributed_mem', 'Block RAM', ...
                'depth', single_rom_size, 'initVector', rom_init_vec), ...
            {addr_a, bram_din, bram_we, addr_b, bram_din, bram_we}, ...
            {real_coeff_rom_out, imag_coeff_rom_out});
        
    else
        real_coeff_rom = xBlock(struct('source', 'ROM', 'name', 'real_coeff_rom'), ...
                            struct('depth', vlen, ...
                                   'initVector', real_coeffs, ...
                                   'distributed_mem', mem, ...
                                   'latency', bram_latency, ...
                                   'n_bits', coeff_bit_width, ...
                                   'bin_pt', coeff_bit_width-2), ...
                            {coeff_addr}, ...
                            {real_coeff_rom_out});

        imag_coeff_rom = xBlock(struct('source', 'ROM', 'name', 'imag_coeff_rom'), ...
                             struct('depth', vlen, ...
                                    'initVector', imag_coeffs, ...
                                    'distributed_mem', mem, ...
                                    'latency', bram_latency, ...
                                    'n_bits', coeff_bit_width, ...
                                    'bin_pt', coeff_bit_width-2), ...
                             {coeff_addr}, ...
                             {imag_coeff_rom_out});
    end
    % block: twiddles_collections/coeff_gen/ri_to_c
    ri_to_c = xBlock(struct('source', str2func('ri_to_c_init_xblock'), 'name', 'ri_to_c'), ...
        [], ...
        {real_coeff_rom_out, imag_coeff_rom_out}, ...
        {w});

end

if ~isempty(blk) && ~strcmp(blk(1),'/')
    clean_blocks(blk);
    fmtstr = sprintf('%d @ (%d,%d)', length(Coeffs), coeff_bit_width, coeff_bit_width-2);
    set_param(blk, 'AttributesFormatString', fmtstr);
end


end

